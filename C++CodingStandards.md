<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [C++编程规范：101条规则、准则与最佳实践](#c%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83101%E6%9D%A1%E8%A7%84%E5%88%99%E5%87%86%E5%88%99%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)
  - [组织与策略问题](#%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98)
    - [0. 不要拘泥与小节/了解哪些东西该标准化](#0-%E4%B8%8D%E8%A6%81%E6%8B%98%E6%B3%A5%E4%B8%8E%E5%B0%8F%E8%8A%82%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%E8%AF%A5%E6%A0%87%E5%87%86%E5%8C%96)
    - [1. 在高警告级别干净利落地编程](#1-%E5%9C%A8%E9%AB%98%E8%AD%A6%E5%91%8A%E7%BA%A7%E5%88%AB%E5%B9%B2%E5%87%80%E5%88%A9%E8%90%BD%E5%9C%B0%E7%BC%96%E7%A8%8B)
    - [2. 使用自动构建系统](#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F)
    - [3. 使用版本控制系统](#3-%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F)
    - [4. 做代码审查](#4-%E5%81%9A%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5)
  - [设计风格](#%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC)
    - [5. 一个实体应该只有一个紧凑的职责](#5-%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%BA%94%E8%AF%A5%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B4%A7%E5%87%91%E7%9A%84%E8%81%8C%E8%B4%A3)
    - [6. 正确、简单和清晰第一](#6-%E6%AD%A3%E7%A1%AE%E7%AE%80%E5%8D%95%E5%92%8C%E6%B8%85%E6%99%B0%E7%AC%AC%E4%B8%80)
    - [7. 编程中应知道何时与如何考虑可伸缩性](#7-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%BA%94%E7%9F%A5%E9%81%93%E4%BD%95%E6%97%B6%E4%B8%8E%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7)
    - [8. 不要进行不成熟的优化](#8-%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96)
    - [9. 不要进行不成熟的劣化](#9-%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%8A%A3%E5%8C%96)
    - [10. 尽量减少全局和共享数据](#10-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E5%85%A8%E5%B1%80%E5%92%8C%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE)
    - [11. 隐藏信息](#11-%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF)
    - [12. 懂得如何和何时进行并发编程](#12-%E6%87%82%E5%BE%97%E5%A6%82%E4%BD%95%E5%92%8C%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)
    - [13. 确保资源为对象所拥有，使用显式的RAII和智能指针](#13-%E7%A1%AE%E4%BF%9D%E8%B5%84%E6%BA%90%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%89%80%E6%8B%A5%E6%9C%89%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%9A%84raii%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88)
  - [编程风格](#%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC)
    - [14. 宁可编译时链接时错误，也不要运行时错误](#14-%E5%AE%81%E5%8F%AF%E7%BC%96%E8%AF%91%E6%97%B6%E9%93%BE%E6%8E%A5%E6%97%B6%E9%94%99%E8%AF%AF%E4%B9%9F%E4%B8%8D%E8%A6%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF)
    - [15. 积极使用const](#15-%E7%A7%AF%E6%9E%81%E4%BD%BF%E7%94%A8const)
    - [16. 避免使用宏](#16-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AE%8F)
    - [17. 避免使用魔法数字](#17-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97)
    - [18. 尽可能局部地声明变量](#18-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B1%80%E9%83%A8%E5%9C%B0%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F)
    - [19. 总是初始化变量](#19-%E6%80%BB%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F)
    - [20. 避免函数过长，避免嵌套过深](#20-%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%BF%87%E9%95%BF%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1)
    - [21. 避免跨编译单元的初始化依赖](#21-%E9%81%BF%E5%85%8D%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BE%9D%E8%B5%96)
    - [22. 尽量减少定义性依赖，避免循环依赖](#22-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E5%AE%9A%E4%B9%89%E6%80%A7%E4%BE%9D%E8%B5%96%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96)
    - [23. 头文件应该自给自足](#23-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BA%94%E8%AF%A5%E8%87%AA%E7%BB%99%E8%87%AA%E8%B6%B3)
    - [24. 总是编写内部包含守卫，不要编写外部包含守卫](#24-%E6%80%BB%E6%98%AF%E7%BC%96%E5%86%99%E5%86%85%E9%83%A8%E5%8C%85%E5%90%AB%E5%AE%88%E5%8D%AB%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E5%A4%96%E9%83%A8%E5%8C%85%E5%90%AB%E5%AE%88%E5%8D%AB)
  - [函数与操作符](#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6)
  - [类的设计与继承](#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BB%A7%E6%89%BF)
  - [构造、析构和复制](#%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E5%92%8C%E5%A4%8D%E5%88%B6)
  - [名称空间与模块](#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%A8%A1%E5%9D%97)
  - [模板与泛型](#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B)
  - [错误处理与异常](#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8)
  - [STL：容器](#stl%E5%AE%B9%E5%99%A8)
  - [STL：算法](#stl%E7%AE%97%E6%B3%95)
  - [类型安全](#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# C++编程规范：101条规则、准则与最佳实践

书籍：《[C++编程规范：101条规则、准则与最佳实践](https://book.douban.com/subject/26899830/)》。

首先：
- 任何准则都不应该代替自己的思考，遵从好的准则，但一定要有自己的思考，不要盲从。
- 另外重在理解为什么，不需要死记硬背。
- 某些规范仅在某些情况下适用，注意使用场景。

## 组织与策略问题

### 0. 不要拘泥与小节/了解哪些东西该标准化

- 摘要：只规定需要规定的东西，不要强制施加个人喜好和过时的东西。
- 比如强制大括号位置、空格制表符、强制匈牙利命名、强制函数单出口等。

### 1. 在高警告级别干净利落地编程

- 摘要：使用编译器的最高警告级别，要求构建干净利落，没有警告。理解所有警告，通过修改代码而不是降低警告级别来排除警告。
- 但实践时警告等级太高可能会导致报出很多不必要甚至虚假的警告，这时候就需要有一定消除手段。可以通过对不可修改的头文件进行包装消除这种警告，处理警告时需要确保已经完全理解了其含义。
- 看到这里我立刻去提高了我的Makefile中的g++警告等级，现在它是：`-Wall -Wextra -Wfatal-errors -pedantic-errors -Wshadow`，基本够用了，如果需要将警告变为错误那么还需要`-Werror`。

### 2. 使用自动构建系统

- 摘要：使用自动构建系统，完全自动化操作，无需用户干预便可构建整个项目。
- 现代C++中，大中型项目应该使用MsBuild、CMake、Xmake等现代化构建工具，小型项目中Makefile依旧可用。
- 现代C++构建系统中的基本功能：增量构建、完全构建、构建范围选择、选择目标架构、调试模式发布模式选择、直接构建生成安装包等。
- 自动构建系统应该在项目启动时就引入，大型项目还会需要专门的构建管理员。

### 3. 使用版本控制系统

- 摘要：使用版本控制系统（VCS，Version Control System），不要让文件长时间脱离版本控制，不要将工作长时间停留在本地以免丢失，应当保证每一次提交都能够成功构建。
- 每个程序员都应该会使用git。

### 4. 做代码审查

- 摘要：代码提交最好都经过审查，相互审查代码，指出问题，互相学习。
- 代码审查（Code Review）应该作为软件开发周期中的常规环节。

## 设计风格

### 5. 一个实体应该只有一个紧凑的职责

- 摘要：只给一个实体（变量、类、函数、名称空间、模块和库）赋予一个定义良好的职责。随着实体变大，职责范围会扩大但不应该发散。
- 一个实体如果具有多个目的，那么除了会增加理解难度、实现复杂度、各部分的错误之外，还会导致很多其他问题。
- 应该实现目的单一的函数、小而且单一的类以及边界清晰的紧凑模块，使用这些简单的功能单一的实体来实现复杂的行为。
- 应该使用较小的底层抽象构建更高层次的抽象，避免将多个底层抽象集合成较大的低层抽象聚合体。

### 6. 正确、简单和清晰第一

- 摘要：软件简单为美，质量优于速度，简单优于复杂，清晰优于机巧，安全优于不安全。
- 代码可读性至关重要，不止有一个人阅读你的代码。即使是自己也不一定能完全看懂自己一个月前写得代码。
- 代码可读性和代码优化很多时候是矛盾的。

### 7. 编程中应知道何时与如何考虑可伸缩性

- 摘要：小心算法复杂度的爆炸增长，不要进行不成熟的提前优化，但是任何时候都应该密切关注算法的复杂度。
- 通过保证复杂度来保证对未来可能面对的更大数据量下的性能。
- 即使可预见的未来不会有特别大的数据量，也应该避免不能很好应付数据量增加的算法（除非这种算法确实过于清晰、简单、可读性强）。
- 一些具体做法：
  - 使用灵活的动态分配的数组，而不是固定大小数组。
  - 了解算法的复杂度。
  - 优先使用快的算法，有对数复杂度就不用线性复杂度，比如能二分查找就绝对不按顺序遍历查找。
  - 即使要优化，也应该尝试优化复杂度，而不是浪费精力在节省一个多余加法这种无关紧要不关乎大局的细节上。

### 8. 不要进行不成熟的优化

- 摘要：优化的第一原则是不要优化，第二原则还是不要优化，第三原则是经过再三测试（profiling）之后再优化。
- 在编写开初就需要考虑复杂度，不要过早就进行复杂的优化，都说过早优化是万恶之源。当性能出现问题时，或者功能完成后才进行优化。
- 优化也应当在严格profiling之后再优化，应当只在必要的情况下优化运行最多的瓶颈代码。
- 而不是浪费时间搞一些完全不重要的、主观臆想的、增加代码复杂程度、降低可读性、打乱架构的特例性优化。

### 9. 不要进行不成熟的劣化

- 摘要：在代码复杂性和可读性相同的情况下，选择高效的设计模式和编程习惯总是更好的。因为并没有以可读性和代码复杂性为代码，所以这是在避免不成熟的劣化，而不是不成熟的优化。
- 例子：将临时变量从循环中提出来，使用前缀`-- ++`，引用传递参数等。

### 10. 尽量减少全局和共享数据

- 摘要：避免共享数据，尤其是全局数据。共享数据会增加耦合，降低可维护性，通常还会降低性能。
- 因为使用共享数据的代码片段不仅取决于数据变化的过程，还取决于以后会使用该数据的未知代码区域的机能。
- 不同编译单元中全局对象的初始化顺序还是不确定的，应尽量避免使用。
- 全局的数据还会降低多线程和多处理器环境下的并行性。
- 即使要用也应该使用工厂来注册与维护。

### 11. 隐藏信息

- 摘要：不要公开提供抽象实体的内部信息。
- 信息隐藏限制了变化的影响范围，强化的不变的东西（接口），降低耦合。

### 12. 懂得如何和何时进行并发编程

- 摘要：如果应用程序使用了多个线程或者进程，应当知道如何尽量减少共享对象，以及如何安全地访问必须共享的对象。
- 具体做法：
  - 了解平台的多线程接口（当然C++11标准已经提供了跨平台的多线程），了解同步原语：原子操作、内存栅栏、互斥体等。
  - 最好将平台原语包装起来自己设计抽象，益于跨平台移植。
  - 确保正在使用的类型是多线程安全的。

### 13. 确保资源为对象所拥有，使用显式的RAII和智能指针

- 摘要：RAII是惯用的正确处理资源的手段。分配原始资源时应当立即将它传递给其管理对象，永远不要在一条语句中分配一个以上对象。
- 实现RAII类时，小心拷贝构造与赋值操作。
- 最好使用智能指针来管理内存。
- 不要在一条语句中分配一个以上对象，因为C++标准对求值顺序的规定很弱，可能申请了一个资源，但是还没有被管理就去申请另一资源，此时抛异常导致第一个资源没有释放（比如在函数调用中）。
- 不要滥用智能指针，如果原始指针够用，那么也没有必要用智能指针。

## 编程风格

讨论更具体的编程问题。

### 14. 宁可编译时链接时错误，也不要运行时错误

- 摘要：能在编译期做的事情，就不要推迟到运行时。能够在编译期检查不变式就应该在编译期做。
- 例子：
  - 编译期条件就在编译期检查。
  - 考虑在合适的场景使用编译期多态代替运行时多态。
  - 使用枚举。
  - 如果经常使用`dynamic_cast`，说明基类提供功能太少了，可以重新设计接口。

### 15. 积极使用const

- 摘要：应尽量使用常量，会带来编译期类型检查。
- 当需要合法在`const`函数中修改变量时，声明为变量为`mutable`（应该用在这种修改不影响对象可观察状态的情况下，比如缓存数据：不影响正确性，只提供更快的性能，数据本身并没有改变）。
- `const`具有传染性。
- 不要强制转换`const`，这通常意味着设计哪里出现了问题。
- 应避免将值传递的参数设置为`const`，避免在参数中使用顶层`const`：在函数声明层面它会被忽略，但是语义约束还在。

### 16. 避免使用宏

- 摘要：避免使用宏。
- C++提供的`const enum inline template namespace`已经取代了宏的大部分功能，并且提供的更安全的语法。
- 宏目前唯二无法替代的地方在于代码片段复用和跨平台，即使要用也应该谨慎使用。包含守卫都已经可以使用`#pragma once`代替了。
- 不要搞那些让人迷惑的宏元编程，大多数人都看不懂。
- 宏的问题在于不“卫生”，它仅仅是一种文本替换，忽略了作用域，忽略了类型系统，忽略了其他所有语言特性，天生是割裂的显得格格不入。
- 即使要用也应该尽快`#undef`取消其定义。

### 17. 避免使用魔法数字

- 摘要：避免显式使用魔法数字，即使它有意义，也应该使用符号名称来替换它。
- 字符串字面量应该使用符号常量来代替，并集中存放方便查找修改和国际化。

### 18. 尽可能局部地声明变量

- 摘要：变量将引入状态，状态的存在时间越短越好，最好只作用于用到它的作用域内。
- 避免污染上下文。
- 常量不引入状态，不适用于本条。
- C++中鼓励即用即声明，有了足够的数据初始化时才声明是一个好选择。
- 将循环内的局部变量提出循环属于特例，可以自行判别该如何选择。

### 19. 总是初始化变量

- 摘要：总是再定义变量定义时初始化，避免使用未初始化的变量导致的错误。
- 一般而言安全性总是优于不必要的性能考虑。

### 20. 避免函数过长，避免嵌套过深

- 摘要：应避免过长的函数与过深的嵌套层次出现。
- 过长的函数与逻辑可能会使其难以维护、错误频出。
- 过深的嵌套层次要求我们在读代码时就维护脑子里面的栈，不利于可读性。
- 例外：如果一个长函数无法拆分，那么最好不要强行拆分。

### 21. 避免跨编译单元的初始化依赖

- 摘要：不同编译单元的名称空间作用域的对象不应该在初始化上相互依赖，因为他们的初始化顺序是未定义的。
- 应避免使用全局或者命名空间作用域的对象，如果一定要用，可以用单例模式代替。单例模式也应该在第一次获取时初始化（一般通过static局部变量来做）。

### 22. 尽量减少定义性依赖，避免循环依赖

- 摘要：如果使用完整声明能够实现，就不要包含完整定义。
- 模块之间不要相互依赖，双向的依赖代表这他们应该是一个模块。

### 23. 头文件应该自给自足

- 摘要：每一个头文件应该要能够独立通过编译，它应该包含它所依赖的所有头文件。
- 但是不要包含不需要的头文件。

### 24. 总是编写内部包含守卫，不要编写外部包含守卫

- 摘要：在所有头文件中使用包含守卫，而不要在其外部使用该头文件的包含守卫。
- 包含守卫的宏应该定义为唯一名称。
- 外部包含守卫已经过时了，不要再使用了。
- 现代C++中最好使用`#pragma once`。

## 函数与操作符

## 类的设计与继承

## 构造、析构和复制

## 名称空间与模块

## 模板与泛型

## 错误处理与异常

## STL：容器

## STL：算法

## 类型安全
