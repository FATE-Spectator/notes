<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [C++编程规范：101条规则、准则与最佳实践](#c%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83101%E6%9D%A1%E8%A7%84%E5%88%99%E5%87%86%E5%88%99%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)
  - [组织与策略问题](#%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98)
    - [0. 不要拘泥与小节/了解哪些东西该标准化](#0-%E4%B8%8D%E8%A6%81%E6%8B%98%E6%B3%A5%E4%B8%8E%E5%B0%8F%E8%8A%82%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%E8%AF%A5%E6%A0%87%E5%87%86%E5%8C%96)
    - [1. 在高警告级别干净利落地编程](#1-%E5%9C%A8%E9%AB%98%E8%AD%A6%E5%91%8A%E7%BA%A7%E5%88%AB%E5%B9%B2%E5%87%80%E5%88%A9%E8%90%BD%E5%9C%B0%E7%BC%96%E7%A8%8B)
    - [2. 使用自动构建系统](#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F)
    - [3. 使用版本控制系统](#3-%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F)
    - [4. 做代码审查](#4-%E5%81%9A%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5)
  - [设计风格](#%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC)
    - [5. 一个实体应该只有一个紧凑的职责](#5-%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%BA%94%E8%AF%A5%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B4%A7%E5%87%91%E7%9A%84%E8%81%8C%E8%B4%A3)
    - [6. 正确、简单和清晰第一](#6-%E6%AD%A3%E7%A1%AE%E7%AE%80%E5%8D%95%E5%92%8C%E6%B8%85%E6%99%B0%E7%AC%AC%E4%B8%80)
    - [7. 编程中应知道何时与如何考虑可伸缩性](#7-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%BA%94%E7%9F%A5%E9%81%93%E4%BD%95%E6%97%B6%E4%B8%8E%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7)
    - [8. 不要进行不成熟的优化](#8-%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96)
    - [9. 不要进行不成熟的劣化](#9-%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%8A%A3%E5%8C%96)
    - [10. 尽量减少全局和共享数据](#10-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E5%85%A8%E5%B1%80%E5%92%8C%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE)
    - [11. 隐藏信息](#11-%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF)
    - [12. 懂得如何和何时进行并发编程](#12-%E6%87%82%E5%BE%97%E5%A6%82%E4%BD%95%E5%92%8C%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)
    - [13. 确保资源为对象所拥有，使用显式的RAII和智能指针](#13-%E7%A1%AE%E4%BF%9D%E8%B5%84%E6%BA%90%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%89%80%E6%8B%A5%E6%9C%89%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%9A%84raii%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88)
  - [编程风格](#%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC)
    - [14. 宁可编译时链接时错误，也不要运行时错误](#14-%E5%AE%81%E5%8F%AF%E7%BC%96%E8%AF%91%E6%97%B6%E9%93%BE%E6%8E%A5%E6%97%B6%E9%94%99%E8%AF%AF%E4%B9%9F%E4%B8%8D%E8%A6%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF)
    - [15. 积极使用const](#15-%E7%A7%AF%E6%9E%81%E4%BD%BF%E7%94%A8const)
    - [16. 避免使用宏](#16-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AE%8F)
    - [17. 避免使用魔法数字](#17-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97)
    - [18. 尽可能局部地声明变量](#18-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B1%80%E9%83%A8%E5%9C%B0%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F)
    - [19. 总是初始化变量](#19-%E6%80%BB%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F)
    - [20. 避免函数过长，避免嵌套过深](#20-%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E8%BF%87%E9%95%BF%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1)
    - [21. 避免跨编译单元的初始化依赖](#21-%E9%81%BF%E5%85%8D%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BE%9D%E8%B5%96)
    - [22. 尽量减少定义性依赖，避免循环依赖](#22-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E5%AE%9A%E4%B9%89%E6%80%A7%E4%BE%9D%E8%B5%96%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96)
    - [23. 头文件应该自给自足](#23-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BA%94%E8%AF%A5%E8%87%AA%E7%BB%99%E8%87%AA%E8%B6%B3)
    - [24. 总是编写内部包含守卫，不要编写外部包含守卫](#24-%E6%80%BB%E6%98%AF%E7%BC%96%E5%86%99%E5%86%85%E9%83%A8%E5%8C%85%E5%90%AB%E5%AE%88%E5%8D%AB%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E5%A4%96%E9%83%A8%E5%8C%85%E5%90%AB%E5%AE%88%E5%8D%AB)
  - [函数与操作符](#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6)
    - [25. 正确选择通过值、引用还是（智能）指针传递参数](#25-%E6%AD%A3%E7%A1%AE%E9%80%89%E6%8B%A9%E9%80%9A%E8%BF%87%E5%80%BC%E5%BC%95%E7%94%A8%E8%BF%98%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0)
    - [26. 保持重载操作符的自然语义](#26-%E4%BF%9D%E6%8C%81%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E4%B9%89)
    - [27. 优先使用算术操作符和赋值操作符的标准形式](#27-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F)
    - [28. 优先使用前缀版本的++和--](#28-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%89%88%E6%9C%AC%E7%9A%84%E5%92%8C--)
    - [29. 考虑重载以避免隐式转换](#29-%E8%80%83%E8%99%91%E9%87%8D%E8%BD%BD%E4%BB%A5%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2)
    - [30. 避免重载&&、||和,](#30-%E9%81%BF%E5%85%8D%E9%87%8D%E8%BD%BD%E5%92%8C)
    - [31. 不要编写依赖于函数参数求值顺序的代码](#31-%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81)
  - [类的设计与继承](#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BB%A7%E6%89%BF)
    - [32. 弄清楚要编写的是哪一种类](#32-%E5%BC%84%E6%B8%85%E6%A5%9A%E8%A6%81%E7%BC%96%E5%86%99%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%80%E7%A7%8D%E7%B1%BB)
    - [33. 用小类代替巨类](#33-%E7%94%A8%E5%B0%8F%E7%B1%BB%E4%BB%A3%E6%9B%BF%E5%B7%A8%E7%B1%BB)
    - [34. 用组合代替继承](#34-%E7%94%A8%E7%BB%84%E5%90%88%E4%BB%A3%E6%9B%BF%E7%BB%A7%E6%89%BF)
    - [35. 避免从并非要设计成基类的类中继承](#35-%E9%81%BF%E5%85%8D%E4%BB%8E%E5%B9%B6%E9%9D%9E%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB%E4%B8%AD%E7%BB%A7%E6%89%BF)
    - [36. 优先提供抽象接口](#36-%E4%BC%98%E5%85%88%E6%8F%90%E4%BE%9B%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3)
    - [37. 公有继承即可替换性：继承，不是为了重用，而是为了被重用](#37-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E5%8D%B3%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%80%A7%E7%BB%A7%E6%89%BF%E4%B8%8D%E6%98%AF%E4%B8%BA%E4%BA%86%E9%87%8D%E7%94%A8%E8%80%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A2%AB%E9%87%8D%E7%94%A8)
    - [38. 实现安全的覆盖](#38-%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E7%9A%84%E8%A6%86%E7%9B%96)
    - [39. 考虑将虚函数声明为非公有的，将公有函数声明为非虚函数](#39-%E8%80%83%E8%99%91%E5%B0%86%E8%99%9A%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA%E9%9D%9E%E5%85%AC%E6%9C%89%E7%9A%84%E5%B0%86%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0)
    - [40. 避免提供隐式转换](#40-%E9%81%BF%E5%85%8D%E6%8F%90%E4%BE%9B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2)
    - [41. 将数据成员设置为成员、无行为的聚集（C语言形式struct）](#41-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%88%90%E5%91%98%E6%97%A0%E8%A1%8C%E4%B8%BA%E7%9A%84%E8%81%9A%E9%9B%86c%E8%AF%AD%E8%A8%80%E5%BD%A2%E5%BC%8Fstruct)
    - [42. 不要公开内部数据](#42-%E4%B8%8D%E8%A6%81%E5%85%AC%E5%BC%80%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE)
    - [43. 明智使用pImpl](#43-%E6%98%8E%E6%99%BA%E4%BD%BF%E7%94%A8pimpl)
    - [44. 优先编写非成员非友元函数](#44-%E4%BC%98%E5%85%88%E7%BC%96%E5%86%99%E9%9D%9E%E6%88%90%E5%91%98%E9%9D%9E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0)
    - [45. 总是一起提供new和delete](#45-%E6%80%BB%E6%98%AF%E4%B8%80%E8%B5%B7%E6%8F%90%E4%BE%9Bnew%E5%92%8Cdelete)
    - [46. 如果为类提供专门的new，那么应该提供所有标准形式（普通、placement、nothrow版本）](#46-%E5%A6%82%E6%9E%9C%E4%B8%BA%E7%B1%BB%E6%8F%90%E4%BE%9B%E4%B8%93%E9%97%A8%E7%9A%84new%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9B%E6%89%80%E6%9C%89%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F%E6%99%AE%E9%80%9Aplacementnothrow%E7%89%88%E6%9C%AC)
  - [构造、析构和复制](#%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E5%92%8C%E5%A4%8D%E5%88%B6)
    - [47. 以同样顺序定义和初始化变量](#47-%E4%BB%A5%E5%90%8C%E6%A0%B7%E9%A1%BA%E5%BA%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F)
    - [48. 在构造函数中使用初始化代替赋值](#48-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E6%9B%BF%E8%B5%8B%E5%80%BC)
    - [49. 避免在构造函数和析构函数中调用虚函数](#49-%E9%81%BF%E5%85%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0)
    - [50. 将基类析构函数设置为公有虚函数或者保护非虚函数](#50-%E5%B0%86%E5%9F%BA%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%85%AC%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E4%BF%9D%E6%8A%A4%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0)
    - [51. 析构、释放和交换绝对不能失败](#51-%E6%9E%90%E6%9E%84%E9%87%8A%E6%94%BE%E5%92%8C%E4%BA%A4%E6%8D%A2%E7%BB%9D%E5%AF%B9%E4%B8%8D%E8%83%BD%E5%A4%B1%E8%B4%A5)
    - [52. 一致地进行复制和销毁](#52-%E4%B8%80%E8%87%B4%E5%9C%B0%E8%BF%9B%E8%A1%8C%E5%A4%8D%E5%88%B6%E5%92%8C%E9%94%80%E6%AF%81)
    - [53. 显式启用或者禁止复制](#53-%E6%98%BE%E5%BC%8F%E5%90%AF%E7%94%A8%E6%88%96%E8%80%85%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6)
    - [54. 避免切片，在基类中考虑使用克隆代替复制](#54-%E9%81%BF%E5%85%8D%E5%88%87%E7%89%87%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%B8%AD%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E4%BB%A3%E6%9B%BF%E5%A4%8D%E5%88%B6)
    - [55. 使用赋值的标准形式](#55-%E4%BD%BF%E7%94%A8%E8%B5%8B%E5%80%BC%E7%9A%84%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F)
    - [56. 只要可行，正确提供不会失败的swap](#56-%E5%8F%AA%E8%A6%81%E5%8F%AF%E8%A1%8C%E6%AD%A3%E7%A1%AE%E6%8F%90%E4%BE%9B%E4%B8%8D%E4%BC%9A%E5%A4%B1%E8%B4%A5%E7%9A%84swap)
  - [名称空间与模块](#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%A8%A1%E5%9D%97)
  - [模板与泛型](#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B)
  - [错误处理与异常](#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8)
  - [STL：容器](#stl%E5%AE%B9%E5%99%A8)
  - [STL：算法](#stl%E7%AE%97%E6%B3%95)
  - [类型安全](#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# C++编程规范：101条规则、准则与最佳实践

书籍：《[C++编程规范：101条规则、准则与最佳实践](https://book.douban.com/subject/26899830/)》。

首先：
- 任何准则都不应该代替自己的思考，遵从好的准则，但一定要有自己的思考，不要盲从。
- 另外重在理解为什么，不需要死记硬背。
- 某些规范仅在某些情况下适用，注意使用场景。

## 组织与策略问题

### 0. 不要拘泥与小节/了解哪些东西该标准化

- 摘要：只规定需要规定的东西，不要强制施加个人喜好和过时的东西。
- 比如强制大括号位置、空格制表符、强制匈牙利命名、强制函数单出口等。

### 1. 在高警告级别干净利落地编程

- 摘要：使用编译器的最高警告级别，要求构建干净利落，没有警告。理解所有警告，通过修改代码而不是降低警告级别来排除警告。
- 但实践时警告等级太高可能会导致报出很多不必要甚至虚假的警告，这时候就需要有一定消除手段。可以通过对不可修改的头文件进行包装消除这种警告，处理警告时需要确保已经完全理解了其含义。
- 看到这里我立刻去提高了我的Makefile中的g++警告等级，现在它是：`-Wall -Wextra -Wfatal-errors -pedantic-errors -Wshadow`，基本够用了，如果需要将警告变为错误那么还需要`-Werror`。

### 2. 使用自动构建系统

- 摘要：使用自动构建系统，完全自动化操作，无需用户干预便可构建整个项目。
- 现代C++中，大中型项目应该使用MsBuild、CMake、Xmake等现代化构建工具，小型项目中Makefile依旧可用。
- 现代C++构建系统中的基本功能：增量构建、完全构建、构建范围选择、选择目标架构、调试模式发布模式选择、直接构建生成安装包等。
- 自动构建系统应该在项目启动时就引入，大型项目还会需要专门的构建管理员。

### 3. 使用版本控制系统

- 摘要：使用版本控制系统（VCS，Version Control System），不要让文件长时间脱离版本控制，不要将工作长时间停留在本地以免丢失，应当保证每一次提交都能够成功构建。
- 每个程序员都应该会使用git。

### 4. 做代码审查

- 摘要：代码提交最好都经过审查，相互审查代码，指出问题，互相学习。
- 代码审查（Code Review）应该作为软件开发周期中的常规环节。

## 设计风格

### 5. 一个实体应该只有一个紧凑的职责

- 摘要：只给一个实体（变量、类、函数、名称空间、模块和库）赋予一个定义良好的职责。随着实体变大，职责范围会扩大但不应该发散。
- 一个实体如果具有多个目的，那么除了会增加理解难度、实现复杂度、各部分的错误之外，还会导致很多其他问题。
- 应该实现目的单一的函数、小而且单一的类以及边界清晰的紧凑模块，使用这些简单的功能单一的实体来实现复杂的行为。
- 应该使用较小的底层抽象构建更高层次的抽象，避免将多个底层抽象集合成较大的低层抽象聚合体。

### 6. 正确、简单和清晰第一

- 摘要：软件简单为美，质量优于速度，简单优于复杂，清晰优于机巧，安全优于不安全。
- 代码可读性至关重要，不止有一个人阅读你的代码。即使是自己也不一定能完全看懂自己一个月前写得代码。
- 代码可读性和代码优化很多时候是矛盾的。

### 7. 编程中应知道何时与如何考虑可伸缩性

- 摘要：小心算法复杂度的爆炸增长，不要进行不成熟的提前优化，但是任何时候都应该密切关注算法的复杂度。
- 通过保证复杂度来保证对未来可能面对的更大数据量下的性能。
- 即使可预见的未来不会有特别大的数据量，也应该避免不能很好应付数据量增加的算法（除非这种算法确实过于清晰、简单、可读性强）。
- 一些具体做法：
  - 使用灵活的动态分配的数组，而不是固定大小数组。
  - 了解算法的复杂度。
  - 优先使用快的算法，有对数复杂度就不用线性复杂度，比如能二分查找就绝对不按顺序遍历查找。
  - 即使要优化，也应该尝试优化复杂度，而不是浪费精力在节省一个多余加法这种无关紧要不关乎大局的细节上。

### 8. 不要进行不成熟的优化

- 摘要：优化的第一原则是不要优化，第二原则还是不要优化，第三原则是经过再三测试（profiling）之后再优化。
- 在编写开初就需要考虑复杂度，不要过早就进行复杂的优化，都说过早优化是万恶之源。当性能出现问题时，或者功能完成后才进行优化。
- 优化也应当在严格profiling之后再优化，应当只在必要的情况下优化运行最多的瓶颈代码。
- 而不是浪费时间搞一些完全不重要的、主观臆想的、增加代码复杂程度、降低可读性、打乱架构的特例性优化。

### 9. 不要进行不成熟的劣化

- 摘要：在代码复杂性和可读性相同的情况下，选择高效的设计模式和编程习惯总是更好的。因为并没有以可读性和代码复杂性为代码，所以这是在避免不成熟的劣化，而不是不成熟的优化。
- 例子：将临时变量从循环中提出来，使用前缀`-- ++`，引用传递参数等。

### 10. 尽量减少全局和共享数据

- 摘要：避免共享数据，尤其是全局数据。共享数据会增加耦合，降低可维护性，通常还会降低性能。
- 因为使用共享数据的代码片段不仅取决于数据变化的过程，还取决于以后会使用该数据的未知代码区域的机能。
- 不同编译单元中全局对象的初始化顺序还是不确定的，应尽量避免使用。
- 全局的数据还会降低多线程和多处理器环境下的并行性。
- 即使要用也应该使用工厂来注册与维护。

### 11. 隐藏信息

- 摘要：不要公开提供抽象实体的内部信息。
- 信息隐藏限制了变化的影响范围，强化的不变的东西（接口），降低耦合。

### 12. 懂得如何和何时进行并发编程

- 摘要：如果应用程序使用了多个线程或者进程，应当知道如何尽量减少共享对象，以及如何安全地访问必须共享的对象。
- 具体做法：
  - 了解平台的多线程接口（当然C++11标准已经提供了跨平台的多线程），了解同步原语：原子操作、内存栅栏、互斥体等。
  - 最好将平台原语包装起来自己设计抽象，益于跨平台移植。
  - 确保正在使用的类型是多线程安全的。

### 13. 确保资源为对象所拥有，使用显式的RAII和智能指针

- 摘要：RAII是惯用的正确处理资源的手段。分配原始资源时应当立即将它传递给其管理对象，永远不要在一条语句中分配一个以上对象。
- 实现RAII类时，小心拷贝构造与赋值操作。
- 最好使用智能指针来管理内存。
- 不要在一条语句中分配一个以上对象，因为C++标准对求值顺序的规定很弱，可能申请了一个资源，但是还没有被管理就去申请另一资源，此时抛异常导致第一个资源没有释放（比如在函数调用中）。
- 不要滥用智能指针，如果原始指针够用，那么也没有必要用智能指针。

## 编程风格

讨论更具体的编程问题。

### 14. 宁可编译时链接时错误，也不要运行时错误

- 摘要：能在编译期做的事情，就不要推迟到运行时。能够在编译期检查不变式就应该在编译期做。
- 例子：
  - 编译期条件就在编译期检查。
  - 考虑在合适的场景使用编译期多态代替运行时多态。
  - 使用枚举。
  - 如果经常使用`dynamic_cast`，说明基类提供功能太少了，可以重新设计接口。

### 15. 积极使用const

- 摘要：应尽量使用常量，会带来编译期类型检查。
- 当需要合法在`const`函数中修改变量时，声明为变量为`mutable`（应该用在这种修改不影响对象可观察状态的情况下，比如缓存数据：不影响正确性，只提供更快的性能，数据本身并没有改变）。
- `const`具有传染性。
- 不要强制转换`const`，这通常意味着设计哪里出现了问题。
- 应避免将值传递的参数设置为`const`，避免在参数中使用顶层`const`：在函数声明层面它会被忽略，但是语义约束还在。

### 16. 避免使用宏

- 摘要：避免使用宏。
- C++提供的`const enum inline template namespace`已经取代了宏的大部分功能，并且提供的更安全的语法。
- 宏目前唯二无法替代的地方在于代码片段复用和跨平台，即使要用也应该谨慎使用。包含守卫都已经可以使用`#pragma once`代替了。
- 不要搞那些让人迷惑的宏元编程，大多数人都看不懂。
- 宏的问题在于不“卫生”，它仅仅是一种文本替换，忽略了作用域，忽略了类型系统，忽略了其他所有语言特性，天生是割裂的显得格格不入。
- 即使要用也应该尽快`#undef`取消其定义。

### 17. 避免使用魔法数字

- 摘要：避免显式使用魔法数字，即使它有意义，也应该使用符号名称来替换它。
- 字符串字面量应该使用符号常量来代替，并集中存放方便查找修改和国际化。

### 18. 尽可能局部地声明变量

- 摘要：变量将引入状态，状态的存在时间越短越好，最好只作用于用到它的作用域内。
- 避免污染上下文。
- 常量不引入状态，不适用于本条。
- C++中鼓励即用即声明，有了足够的数据初始化时才声明是一个好选择。
- 将循环内的局部变量提出循环属于特例，可以自行判别该如何选择。

### 19. 总是初始化变量

- 摘要：总是再定义变量定义时初始化，避免使用未初始化的变量导致的错误。
- 一般而言安全性总是优于不必要的性能考虑。

### 20. 避免函数过长，避免嵌套过深

- 摘要：应避免过长的函数与过深的嵌套层次出现。
- 过长的函数与逻辑可能会使其难以维护、错误频出。
- 过深的嵌套层次要求我们在读代码时就维护脑子里面的栈，不利于可读性。
- 例外：如果一个长函数无法拆分，那么最好不要强行拆分。

### 21. 避免跨编译单元的初始化依赖

- 摘要：不同编译单元的名称空间作用域的对象不应该在初始化上相互依赖，因为他们的初始化顺序是未定义的。
- 应避免使用全局或者命名空间作用域的对象，如果一定要用，可以用单例模式代替。单例模式也应该在第一次获取时初始化（一般通过static局部变量来做）。

### 22. 尽量减少定义性依赖，避免循环依赖

- 摘要：如果使用完整声明能够实现，就不要包含完整定义。
- 模块之间不要相互依赖，双向的依赖代表这他们应该是一个模块。

### 23. 头文件应该自给自足

- 摘要：每一个头文件应该要能够独立通过编译，它应该包含它所依赖的所有头文件。
- 但是不要包含不需要的头文件。

### 24. 总是编写内部包含守卫，不要编写外部包含守卫

- 摘要：在所有头文件中使用包含守卫，而不要在其外部使用该头文件的包含守卫。
- 包含守卫的宏应该定义为唯一名称。
- 外部包含守卫已经过时了，不要再使用了。
- 现代C++中最好使用`#pragma once`。

## 函数与操作符

### 25. 正确选择通过值、引用还是（智能）指针传递参数

- 摘要：正确传递参数，分清输入参数、输出参数、输入输出参数。
- 不要使用C语言风格的变长参数。

### 26. 保持重载操作符的自然语义

- 摘要：只有在有充分理由时才重载操作符，而且应当保持其自然语义。
- 如果无法做到这一点，那么大概率不应该使用运算符重载。
- 如果一定要使用运算符重载设计一门DSL，那么最好谨慎设计、让他们保持自洽并且不与现有运算符冲突。

### 27. 优先使用算术操作符和赋值操作符的标准形式

- 摘要：如果要定义以算术运算符，那么最好定义其复合赋值运算符，并且最好是通过复合赋值来实现算术运算符。
- 算术运算版本应该返回临时变量。
- 最好将运算符定义为非成员版本以提供转换。
- 某些情况下用算术运算符版本来实现复合赋值可能更好。

### 28. 优先使用前缀版本的++和--

- 摘要：重载`++`和`--`应当重载前缀后缀两个版本，并且行为模仿内置运算符。并且在不使用原值时最好使用前缀版本。
- 前缀版本性能更好一些，不过这点性能真的重要吗，并且编译器会优化。当然这也是避免不成熟的劣化。

### 29. 考虑重载以避免隐式转换

- 摘要：隐式类型转换提供了语法便利，但如果创建临时对象的工作并不必要并且使用原类型更适合优化，那么可以重载提供精确匹配的版本。

### 30. 避免重载&&、||和,

- 摘要：内置的`&& || ,`具有求值顺序规定，而重载的版本则没有，无法实现和内置版本完全相同的语义，应当避免重载重载这几个运算符。
- 没有了确定求值顺序，就无法保证`&& ||`的短路求值了。那么`p && p->something`这种代码可能就会出现错误，这种代码是不健壮的。
- 表达式模板是例外，因为表达式模板的模板就是用来捕获操作符。

### 31. 不要编写依赖于函数参数求值顺序的代码

- 摘要：函数参数的求值顺序是不确定的，不要依赖于此编程。
- 可以通过使用命名对象控制求值顺序。

## 类的设计与继承

### 32. 弄清楚要编写的是哪一种类

- 摘要：不同种类的类适用于不通过用途，因此遵循不同规则，弄清楚要编写的是哪一种。
- 值类：
    - 拥有公有析构、拷贝构造、带有值语义的赋值。
    - 没有虚函数，包括析构。
    - 用作具体类，而不是基类。
    - 总是在栈中实例化，或者作为另一个类直接包含的成员实例化。
- 基类：
    - 存在一个公有且虚拟、或者保护而且非虚拟的析构，和一个非公有的拷贝构造与赋值运算符。
    - 通过虚函数建立接口。
    - 总是动态在堆中实例化为具体派生类对象，并通过指针来管理。
- 特征类：
    - 只包含嵌套类型声明与静态数据或者函数，没有可改变状态或者虚函数。
    - 通常不实例化。
- 异常类：
    - 有一个公有析构函数和不会失败的构造函数（特别是拷贝构造）。
    - 有虚函数，经常实现克隆和访问。
    - 从`std::exception`比较好。
- 还有比如RAII类等。

### 33. 用小类代替巨类

- 摘要：小类更容易编写，更容易保证正确、测试和使用。小类更可能适用于各种场合，应该使用小类体现简单概念，而不是大杂烩式的类。
- 小类更易编写与重用，大类更加难以编写和使用。
- 巨类更难以保证正确性。
- 人的需求总在变，尝试提供完整解决方案几乎总会失败。

### 34. 用组合代替继承

- 摘要：继承的耦合非常紧密，仅次于友元。如果能够使用组合代替继承，那么最好使用组合代替继承，除非继承有明显的设计好处。
- 有了继承之后，人们经常拿着锤子看什么都是钉子，继承很容易被滥用。
- 除非要用到继承的东西（重写虚函数、派生类替换基类），否则不要使用继承。

### 35. 避免从并非要设计成基类的类中继承

- 摘要：本意就不是作为基类来设计的类不应作为基类被继承，这是一种严重的设计错误。如果要添加行为，应该添加非成员函数而不是成员函数，要添加数据应该使用组合而不是继承。

### 36. 优先提供抽象接口

- 摘要：抽象接口有助于集中精力保证抽象的正确性，不至于受到实现或者状态管理细节的干扰。优先采用实现了抽象接口的设计层级结构。
- 抽象接口是完全由纯虚函数组成的抽象类，没有状态（数据成员），通常也没有成员函数实现。
- 遵循依赖倒置原则（DIP, Dependency Inversion Principle）：
    - 高层模块不应该依赖低层模块，两者都应该依赖抽象。
    - 抽象不应该依赖细节，细节应该依赖抽象。
- DIP具有三个优点：更强健壮性、更大灵活性、更好模块性。

### 37. 公有继承即可替换性：继承，不是为了重用，而是为了被重用

- 摘要：公有继承能够使基类指针或者引用指向派生类对象。不要通过公有继承重用基类代码（指通过派类对象或者指针引用），而是为了被已经多态使用的基对象的已有代码重用的。
- 继承的使用应该遵循里氏替换原则，即派生类指针引用能够完美替换基类指针引用，满足Is-A关系。
- 所以派生类必须正确实现基类接口该有的功能，这种语义约定必须被遵守，不然就是误用。
- 并且Is-A的关系并非简单的“是一个”，而更类似于“行为像一个”（或者说“可以用作一个”），比如正方形是一个矩形，但是正方形从矩形继承却是怎么看都不合适的。
- 公有继承的目的并非重用，而是为了实现**可替换性**。
- 当然现实中实践时可能某些情况下完全不会使用其可替换性，而仅仅是为了重用，这种情况按照书中描述应该**使用组合或者非公有继承**来实现。
- 通过添加新派生类添加功能时，不需要修改现有使用基类指针引用的代码，这满足开闭原则（对扩展开放，对修改关闭）。
- 特例：策略类和混入类（MixIn）通过公有继承添加行为，这不是误用。

### 38. 实现安全的覆盖

- 摘要：重写一个虚函数时，要保持其可替换性。更具体一点，要保持基类虚函数的前后置条件，不要改变虚函数默认参数。应该显式声明为`vritual override`。
- 可替换性在于多个方面：
    - 重写的函数可以要求更少提供更多，但不可以要求更多承诺更少。
    - 如果基类虚函数承诺不会失败，那么派生类重写后不应抛出异常。
    - 重写虚函数永远不应该修改其默认参数，它们不是函数签名一部分，修改默认参数可能导致奇怪的错误，通过基类指针引用多态调用使用的总是基类的默认参数。
- 应该显式声明重写的虚函数为`virtual`和`override`，借由编译器检查保证正确性。
- 谨防在派生类中隐藏基类虚函数，这可能会发生在虚函数本身有重载的情况下，只重写了一个那么另一个由于作用域嵌套关系会先找到派生类函数。解决方法是使用`using`引入基类函数。

### 39. 考虑将虚函数声明为非公有的，将公有函数声明为非虚函数

- 摘要：在基类中进行修改代价高昂：可以将公有函数函数设置为非虚的，并且将虚函数设置为私有，如果派生类需要调用基类版本则设置为保护。
- 这就是NVI（非虚接口，Non Virtual Interface）模式。
- 公有虚接口其实提供了两个职责：指定接口，指定实现细节。这两件事职责和动机不同，有些时候会冲突。
- 使用非虚接口后，公有非虚接口只提供接口，虚函数不再提供接口。可以有更高的灵活性，并且能够健壮地适应变化。
- 特例：
    - 对析构函数不适用。
    - NVI不支持调用者的协变返回类型（即返回基类虚函数指针引用的底层类型的派生类的指针引用）。

### 40. 避免提供隐式转换

- 摘要：隐式类型转换通常利大于弊，为自定义类型提供隐式类型转换之前，需要三思。应该依赖显式类型转换（explicit转换构造与转换运算符）。
- 通常来说，只有非常直观的非常合理的隐式类型转换才应该被使用。单参数的构造如果不确定那么最好都加上`explicit`。
- 转换运算符可以通过提供命名转换函数替代。

### 41. 将数据成员设置为成员、无行为的聚集（C语言形式struct）

- 摘要：将数据设置为私有的。只有表示数据的聚合类才会将数据成员设置为公有。
- 私有数据成员封装实现，所有修改都通过接口来实现，是可预测的。公有数据成员则是混乱和无法预测的。
- 考虑使用`pImpl`惯用法来隐藏类的私有成员（通常只针对提供给外部的SDK这样以做到二进制兼容与隐藏实现细节）。
- 在没有更好方法的情况下，使用`getter/setter`都是可以接受的。提供最小的抽象以及健壮的版本管理。
- getter/setter很好用，但是主要有getter/setter组成的类可能是一种设计不良的表现。这种时候应该要仔细思考一下，是否应该定义为一个聚合类。不提供抽象，仅保存数据。

### 42. 不要公开内部数据

- 摘要：避免返回类所管理的内部数据的句柄，这样类的客户就不会不受控制在对象不知情的情况下修改对象的状态。
- 客户应该通过你提供的接口来进行和内部数据有关的一切操作，你应该将操作封装好以供用户调用。
- 用户都不应该知道你内部有这样一个东西，也就是接口不应该依赖于实现。
- 在完全知情的情况下为了方便可以提供，不过不应该直接提供，而应该通过中间层/后门的方式提供给自己用，而不能直接提供给用户。

### 43. 明智使用pImpl

- 摘要：C++将私有成员指定为不可访问，但没有指定为不可见。如果要将数据成员变得真正不可见，可以使用pImpl手法。
- 这样做即使修改了数据成员也能能够保持二进制兼容。
- 只应该用在确实要隐藏数据成员时：通常用在要提供给用户的SDK中，内部使用则一般不必要。

### 44. 优先编写非成员非友元函数

- 摘要：尽可能将函数指定为非成员非友元函数。
- 如果一个函数没有用到内部数据，只用到公有成员那么就可以这么做，也应该这么做。

### 45. 总是一起提供new和delete

- 摘要：每个类重载的`operator new`都必须要有对应的`operator delete`。
- 因为构造时如果分配了内存但是构造抛出异常，那么会调用对应`operator delete`来释放，如果没有则不会调用从而导致内存泄漏。

### 46. 如果为类提供专门的new，那么应该提供所有标准形式（普通、placement、nothrow版本）

- 摘要：如果定义了`operator new`，那么就应该定义普通版本、nothrow版本和placement版本。
- 因为为一个类定义`operator new`就会隐藏全局的所有`operator new`，所以为了能够使用这三种变体，应该提供三个版本的`operator new`。
- 当然并非说一定要定义3个，这个条款只是为了提醒不要因为疏忽而隐藏他们，定义时要考虑清楚要定义哪些。
- 数组版本`operator new[]`同理。

## 构造、析构和复制

### 47. 以同样顺序定义和初始化变量

- 摘要：成员初始化顺序要与类定义中声明顺序始终保持一致。最好做法是构造函数初始化列表中的初始化顺序与声明顺序一致。
- 以避免初始化的变量之间有依赖造成的问题。
- g++中开启`-Wreorder`可以在构造函数初始化列表中顺序与数据成员声明顺序不一致时提供警告。
- 一般来说还是尽量不要让一个成员的初始化依赖另一个成员最好。

### 48. 在构造函数中使用初始化代替赋值

- 摘要：如题。
- 因为没有在构造函数初始化列表中的数据成员会执行默认初始化，再赋值会导致性能下降。
- 例外：应该在构造函数体内进行非托管资源获取。

### 49. 避免在构造函数和析构函数中调用虚函数

- 摘要：如题。
- 因为构造函数是先基类后派生类，析构函数是先派生类后基类。
- 所以在构造函数和析构函数中调用虚函数并不会调用到派生类重写的虚函数，只会调用到自己的或者继承而来的。
- 如果希望在构造函数中调用虚函数，可以有几种解决方案：
    - 可以使用后构造函数（post-constructor），也就是构造函数执行完后的类似于`init`这样的初始化函数。这时需要在文档中注明需要这样做，由用户来调用。
    - 可以在第一次调用成员函数时进行初始化，存一个布尔标志做一个判断即可。
    - 使用工厂函数，在其中初始化。

### 50. 将基类析构函数设置为公有虚函数或者保护非虚函数

- 摘要：如题。
- 如果允许通过基类指针引用析构对象，那么析构一定要可见（公用）并且必须是虚函数。
- 如果不允许通过基类指针析构对象，那么则没有必要定义为虚函数，并且需要设置为保护以避免外部调用。
- 总是为基类编写析构函数，因为隐式生成的是公有且非虚的。

### 51. 析构、释放和交换绝对不能失败

- 摘要：决不允许析构函数、资源释放函数、交换函数报告错误。
- 如果无法安全的析构、释放资源、交换，那么无法安全的撤销与回滚（这常见与RAII对象的析构中），那么也就无法实现不会失败的提交。
- 在捕获到异常时，会对已经构造的对象调用析构，配合RAII就保证了资源在异常发生时也能够正确释放。如果析构不保证不会失败，那么就可能发生抛异常时的析构处理再抛异常，此时程序会直接终止（`std::terminate`）。

### 52. 一致地进行复制和销毁

- 摘要：如果定义了拷贝构造、拷贝赋值、析构中的任何一个，那么可能也需要定义另外两个。
- 定义以就意味着要做默认行为之外的事情，而这三个函数是不对称相关的。

### 53. 显式启用或者禁止复制

- 摘要：在以下三种行为中进行选择——使用编译器生成的拷贝构造和拷贝赋值、编写自己的版本、如果不允许赋值那么显式禁用前两者。
- 对于值语义的类，编译器生成的往往符合要求。但对于需要自己管理资源的类，则常常不符合。
- 根据需要声明为`=default =delete`比直接用默认行为要更好，仔细思考类的行为，如果不需要则应该禁用，如果可使用默认生成的版本，则最好显式声明为`=default`。

### 54. 避免切片，在基类中考虑使用克隆代替复制

- 摘要：多态复制的话，考虑禁用拷贝构造与拷贝赋值，而改用克隆函数复制对象。
- 因为拷贝构造和拷贝赋值都是值语义的，派生类对象对基类对象赋值会导致切片。
- 标准做法是在基类声明`clone`虚函数，每个派生类根据自己的类型重写。

### 55. 使用赋值的标准形式

- 摘要：实现赋值运算符时，应该使用标准形式——具有特定签名的非虚形式。
- 即：
```C++
T& operator=(const T&);
T& operator=(T);
```
- 通常定义为第一个形式，如果通过交换实现，那么则选用第二个（在引入移动语义后第二个还能统一移动语义和拷贝语义）。
- 不要将赋值运算符定义为虚函数，如果需要这么做，那么定义一个这种功能的其他函数（命名为比如`assign`）。
- 需要确保自赋值是安全的。基于交换的版本是天然自赋值安全的。

### 56. 只要可行，正确提供不会失败的swap

- 摘要：考虑提供一个安全的不会失败的`swap`以实现高效的交换。
- 并同时对`std::swap`提供特化，调用成员版的`swap`即可。
- 对于许多标准库算法，提供`swap`会提升效率。不提供则会使用标准库版本的通过拷贝构造和拷贝赋值（移动构造、移动赋值）来实现的版本。
- 对于值语义的类来说，提供交换是有用的，对于基类来说往往就没什么用了（一般通过指针使用）。

## 名称空间与模块

## 模板与泛型

## 错误处理与异常

## STL：容器

## STL：算法

## 类型安全
