<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Effective C++ 记录与速览](#effective-c-%E8%AE%B0%E5%BD%95%E4%B8%8E%E9%80%9F%E8%A7%88)
  - [第一章：习惯C++](#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E6%83%AFc)
    - [条款1：视C++为一个语言的联邦](#%E6%9D%A1%E6%AC%BE1%E8%A7%86c%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E7%9A%84%E8%81%94%E9%82%A6)
    - [条款2：以const,enum,inline替换#define](#%E6%9D%A1%E6%AC%BE2%E4%BB%A5constenuminline%E6%9B%BF%E6%8D%A2define)
    - [条款3：尽可能使用const](#%E6%9D%A1%E6%AC%BE3%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const)
    - [条款4：确定对象使用前已被初始化](#%E6%9D%A1%E6%AC%BE4%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96)
  - [第二章：构造/析构/赋值运算](#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97)
    - [条款5：了解C++默认生成了哪些函数](#%E6%9D%A1%E6%AC%BE5%E4%BA%86%E8%A7%A3c%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0)
    - [条款6：若不想使用编译器自动生成的函数，就应该明确拒绝](#%E6%9D%A1%E6%AC%BE6%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D)
    - [条款7：为多态基类声明虚析构函数](#%E6%9D%A1%E6%AC%BE7%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
    - [条款8：别让异常逃离析构函数](#%E6%9D%A1%E6%AC%BE8%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
    - [条款9：永远不要在构造和析构函数中调用虚函数](#%E6%9D%A1%E6%AC%BE9%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0)
    - [条款10：令operator=返回一个*this的引用](#%E6%9D%A1%E6%AC%BE10%E4%BB%A4operator%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAthis%E7%9A%84%E5%BC%95%E7%94%A8)
    - [条款11：在operator=中处理自我赋值](#%E6%9D%A1%E6%AC%BE11%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC)
    - [条款12：赋值对象勿要忘记其每一个成分](#%E6%9D%A1%E6%AC%BE12%E8%B5%8B%E5%80%BC%E5%AF%B9%E8%B1%A1%E5%8B%BF%E8%A6%81%E5%BF%98%E8%AE%B0%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Effective C++ 记录与速览

- C++的一些最佳实践，也就是怎么避开坑写出好的代码。
- 本书按照章节和条款组织内容。这里简单总结，细节建议直接去看书。
- 第三版成书2005年，所以C++11及之后的新特性可能不会被讲到，但在传统C++和现代C++中这本书里的东西基本都是通用的。
- 很大一部分在C++Primer中都已经提到过了，只是这里单独提出来讲了。

## 第一章：习惯C++

### 条款1：视C++为一个语言的联邦

C++的多个编程范式：
- 继承自C的过程式编程
- C with classes的面向对象编程
- 基于模板的泛型编程，深奥的模板元编程
- STL，标准模板库

当从一个范式切换到另一个时，编程策略可能需要改变。每个子语言会有自己的规约和属于自己的最佳实践，用的哪一个部分，就使用什么原则。必须对这一点有强烈意识。

### 条款2：以const,enum,inline替换#define

- 以全局的常量定义替换宏定义的常量，以提供类型检查等一系列好处。
- 用enum值替换宏定义得到编译期常量，以避免非必要内存消耗，在模板中广泛使用(aka enum hack)。
- 用（模板）内联inline函数替换带参宏，获得更加健壮的程序。

宏定义和条件编译依然会扮演重要角色，但不再所有事情都要交给他们来做。

### 条款3：尽可能使用const

const可以修饰基本任何变量：
- 在所有可能的地方使用const，常量，返回值（避免对右值的修改），参数（避免对参数的修改），成员函数（支持const对象调用）。
- 充分理解指针引用的顶层底层const。
- 将所有不会修改对象的成员函数定义为const，以提供const对象或者const引用参数来访问。
- 在const对象中有想要修改的内容可以使用mutable。
- const和non-const重载成员函数逻辑相似，可以用non-const调用const辅以const_cast来避免重复（注意绝不应该反过来做）。

### 条款4：确定对象使用前已被初始化

不同部分的C++：
- 源自于C部分可能会沿用C的行为，对未初始化的内置类型变量不做任何事情，保持其为内存中的随机值。如局部变量，数组，类的内建成员等。
- 使用C++部分则会对内置类型做值初始化，如容器中的元素。
- 自定义类型的默认初始化由默认构造函数完成。

原则：
- 在任何时候保证对内置类型做初始化能避免很多错误，C++并不保证初始化他们。
- 使用构造函数成员初始化列表而非在构造函数体中对成员进行赋值以提高效率。
- 类中数据成员有着确定的初始化顺序，基类、成员按照声明顺序依次初始化，避免构造成员的初始化有数据依赖。
- 注意不同编译单元中的非局部静态对象的初始化顺序没有任何保证，避免这些对象的初始化之间存在依赖关系。
    - 最佳实践：使用单例模式返回局部静态变量的引用以替代全局的静态对象。规避初始化次序问题同时还能即用即初始化。

## 第二章：构造/析构/赋值运算

### 条款5：了解C++默认生成了哪些函数

- C++在一些情况下会默认生成默认构造函数、析构函数、拷贝构造函数、拷贝赋值运算符。
- 在已经有构造函数声明的情况下，不会生成默认构造。
- 在生成的函数的默认行为不合理、无法做到时则会将其生成为删除的函数。
    - 比如类中含有const成员、引用成员时拷贝赋值运算符会生成为删除。
    - 某个成员或者基类析构函数不可用时析构函数会生成为删除。
    - 某个成员或者基类没有默认构造时、有const或者引用成员时默认构造生成为删除。

### 条款6：若不想使用编译器自动生成的函数，就应该明确拒绝

不想要编译器默认生成的行为时，应该使用=delete明确声明为删除，或者自己定义。
- 在不支持=delete特性时比较老式的表达删除一个函数的意思的伎俩是：
    - 将不想要生成的函数声明为private，并且不做实现。
    - 或者继承一个拷贝构造、拷贝赋值被定义为private且未实现的基类Uncopyable。
- 当然现代C++中使用=delete就行了，不用这么绕弯子。

### 条款7：为多态基类声明虚析构函数

这已经是任何一个菜鸟都知道的共识了！

要点：
- 如果一个类要作为基类，那么可以肯定它需要一个虚析构函数。
- 如果一个类不会作为基类，那么不要将析构函数定义为虚函数。会增加一个虚指针的内存消耗。
- 如果你想要一个抽象类，但又找不到合适的函数来定义为虚函数。那么可以将析构函数定义为纯虚函数，但是同时也需要为其提供定义（合法可行且必须这样做，即使是抽象类甚至纯虚类，派生后这个子对象也是需要析构的）。
- 不要继承没有定义虚析构函数的类作为基类，使用多态特性时会出现内存泄漏。使用final阻止继承。

### 条款8：别让异常逃离析构函数

因为异常处理的过程中会调用析构函数销毁对象，如果在这期间再发生异常，那么将会导致UB。
- 所以永远不要在析构函数中抛出异常。
- 析构函数中的可能发生的异常都需要在函数体中就得到恰当的处理。
- 如果析构会发生无法恢复的异常，那么直接结束程序告知用户是一个好主意。
- 当然无法处理时另一个选择也可以选择吞掉异常，这取决于程序维持稳定运行重要还是暴露出所有的一个错误更重要。当然即使吞掉异常也应该将其记录在日志上之类的手段将其记录下来。
- 另一个策略是重新设计接口，将这些操作从析构函数中分离出来，将调用失败的处理交给使用类的客户去做。如果客户需要对这些异常做出反应，那么将其放在一个普通函数里面来做就是必须的。

### 条款9：永远不要在构造和析构函数中调用虚函数

因为在此时调用虚函数并不会达到我们想要的行为。
- 构造函数中，基类构造先与派生类构造，在构造基类时，this指代的对象是基类对象，虚函数当然也不会被解析为派生类的虚函数，因为这时候派生类成员都还没有被初始化。
- 析构函数中，派生类析构先与基类析构，在基类析构时，this同样指代基类对象，虚函数当然也会被解析为基类虚函数，此时派生类的成员已经被销毁了。
- 因为在执行基类的构造和析构时，派生类中的成员都是不可以用的，要么还没有初始化，要么已经销毁，所以这时不能将虚函数下降至派生类。
- 即是在构造函数和析构函数中，虚函数是不具备多态的，此时this也是指向该基类对象，而非派生类对象。此时做RTTI，`typeid(*this)`得到的将会是基类的`type_info`对象，`dynamic_cast`为派生类对象将会失败（而且这时派生类都不是完整类型，这样做必然是编不过的）。
- 除了不直接在构造和析构中调用虚函数，也应当注意不要间接调用虚函数。【当然除非这就是你期望的行为】。

### 条款10：令operator=返回一个*this的引用

这也是常识了，为了和内置赋值对标，为自定义类型重载赋值，前置++/--，取成员，解引用这种返回左值的运算符都应该返回一个左值引用。以实现和内置类型类似的语义。

当然这并不是强制的，只是这是最佳实践，为了减少心智负担而已。

### 条款11：在operator=中处理自我赋值

我们应该假定使用代码的人可能会做出任何事情，包括自己给自己赋值，虽然这什么也不会发生。
- 某些时候赋值运算符中的逻辑本身就可以正确处理自赋值的情况，但某些情况并不能，每次写赋值运算符都应该考虑这种情况。
- 比如类中申请了内存，不要急于在还未复制右侧对象内存之前，就将自己的内存释放掉。
- 如果不好通过调整赋值中的操作顺序来处理自我赋值，那么也可以显式做一个判断。
- 通常的做法时，复制了右侧对象的内容分配好了新内存之后，再来释放左侧对象内存，兼具自我赋值安全和异常安全。
- 使用copy and swap技术来处理自我赋值也是一种常见手段：
    - 可以使用const引用传参，在拷贝复制内部做拷贝之后和左侧对象做swap。
    - 也可以使用另一种更加巧妙的手段：使用值传递（在此时复制），内部做交换之后返回`*this`。这种方式还会将移动赋值和拷贝赋值统一到一个赋值运算符中。
    - 适用于在实现了对象交换的类型（特化了`std::swap`）中这样做。

这也算是基本常识了。

### 条款12：赋值对象勿要忘记其每一个成分

- 拷贝构造和拷贝赋值运算符中一定不要忘记复制每一个成员。（所以，为类添加新成员时千万不要忘记在构造函数中添加初始化，在拷贝控制成员中添加其复制逻辑，如果有必要析构函数中也需要处理）。
- 除了自己的成员之外，如果是对一个派生类实现拷贝构造和拷贝赋值，那么一定不要忘记去对自己的基类部分执行拷贝。
    - 特别地，应该在拷贝赋值运算符中调用`Base::operator=(rhs)`。
- 通常来说，拷贝构造和拷贝赋值运算符不应该互相调用，因为前者是构造一个新对象，后者是对一个已有对象赋值覆盖其原有状态。如果两者有很多重复逻辑，应该定义一个新的私有成员函数给两者使用（通常命名为`init`）。