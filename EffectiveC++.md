<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Effective C++ 记录与速览](#effective-c-%E8%AE%B0%E5%BD%95%E4%B8%8E%E9%80%9F%E8%A7%88)
  - [第一章：习惯C++](#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E6%83%AFc)
    - [条款1：视C++为一个语言的联邦](#%E6%9D%A1%E6%AC%BE1%E8%A7%86c%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E7%9A%84%E8%81%94%E9%82%A6)
    - [条款2：以const,enum,inline替换#define](#%E6%9D%A1%E6%AC%BE2%E4%BB%A5constenuminline%E6%9B%BF%E6%8D%A2define)
    - [条款3：尽可能使用const](#%E6%9D%A1%E6%AC%BE3%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const)
    - [条款4：确定对象使用前已被初始化](#%E6%9D%A1%E6%AC%BE4%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96)
  - [第二章：构造/析构/赋值运算](#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97)
    - [条款5：了解C++默认生成了哪些函数](#%E6%9D%A1%E6%AC%BE5%E4%BA%86%E8%A7%A3c%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0)
    - [条款6：若不想使用编译器自动生成的函数，就应该明确拒绝](#%E6%9D%A1%E6%AC%BE6%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D)
    - [条款7：为多态基类声明虚析构函数](#%E6%9D%A1%E6%AC%BE7%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
    - [条款8：别让异常逃离析构函数](#%E6%9D%A1%E6%AC%BE8%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
    - [条款9：永远不要在构造和析构函数中调用虚函数](#%E6%9D%A1%E6%AC%BE9%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0)
    - [条款10：令operator=返回一个*this的引用](#%E6%9D%A1%E6%AC%BE10%E4%BB%A4operator%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAthis%E7%9A%84%E5%BC%95%E7%94%A8)
    - [条款11：在operator=中处理自我赋值](#%E6%9D%A1%E6%AC%BE11%E5%9C%A8operator%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC)
    - [条款12：赋值对象勿要忘记其每一个成分](#%E6%9D%A1%E6%AC%BE12%E8%B5%8B%E5%80%BC%E5%AF%B9%E8%B1%A1%E5%8B%BF%E8%A6%81%E5%BF%98%E8%AE%B0%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86)
  - [第三章：资源管理](#%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86)
    - [条款13：以对象管理资源](#%E6%9D%A1%E6%AC%BE13%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90)
    - [条款14：资源管理类中小心复制行为](#%E6%9D%A1%E6%AC%BE14%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E5%A4%8D%E5%88%B6%E8%A1%8C%E4%B8%BA)
    - [条款15：在资源管理类中提供对原始资源的访问](#%E6%9D%A1%E6%AC%BE15%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE)
    - [条款16：成对使用new和delete时采取相同形式](#%E6%9D%A1%E6%AC%BE16%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F)
    - [条款17：以独立语句将new得到的指针置入智能指针](#%E6%9D%A1%E6%AC%BE17%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%BE%97%E5%88%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88)
  - [第四章：设计与声明](#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E)
    - [条款18：让接口容易被正确使用，不易被误用](#%E6%9D%A1%E6%AC%BE18%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8)
    - [条款19：像设计类型一样设计类](#%E6%9D%A1%E6%AC%BE19%E5%83%8F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%A0%B7%E8%AE%BE%E8%AE%A1%E7%B1%BB)
    - [条款20：以const引用参数替代值传递](#%E6%9D%A1%E6%AC%BE20%E4%BB%A5const%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E6%9B%BF%E4%BB%A3%E5%80%BC%E4%BC%A0%E9%80%92)
    - [条款21：必须返回对象时，不要试图返回引用](#%E6%9D%A1%E6%AC%BE21%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%B8%8D%E8%A6%81%E8%AF%95%E5%9B%BE%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8)
    - [条款21：将成员变量声明为private](#%E6%9D%A1%E6%AC%BE21%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate)
    - [条款23：宁以非成员、非友元替换成员函数](#%E6%9D%A1%E6%AC%BE23%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E9%9D%9E%E5%8F%8B%E5%85%83%E6%9B%BF%E6%8D%A2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0)
    - [条款24：若所有函数皆需类型转换，请为此采用非成员函数](#%E6%9D%A1%E6%AC%BE24%E8%8B%A5%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0)
    - [条款25：考虑写出一个不抛出异常的swap函数](#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0)
  - [第五章：实现](#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AE%9E%E7%8E%B0)
    - [条款26：尽可能延后变量定义的出现时间](#%E6%9D%A1%E6%AC%BE26%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4)
    - [条款27：尽量少做转型](#%E6%9D%A1%E6%AC%BE27%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B)
    - [条款28：避免返回指向对象内部成分的句柄（handle）](#%E6%9D%A1%E6%AC%BE28%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86%E7%9A%84%E5%8F%A5%E6%9F%84handle)
    - [条款29：为异常安全而努力是值得的](#%E6%9D%A1%E6%AC%BE29%E4%B8%BA%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84)
    - [条款30：透彻了解inline的里里外外](#%E6%9D%A1%E6%AC%BE30%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inline%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96)
    - [条款31：将文件间的编译依存关系降至最低](#%E6%9D%A1%E6%AC%BE31%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Effective C++ 记录与速览

- C++的一些最佳实践，也就是怎么避开坑写出好的代码。
- 本书按照章节和条款组织内容。这里简单总结，细节建议直接去看书。
- 第三版成书2005年，所以C++11及之后的新特性可能不会被讲到，但在传统C++和现代C++中这本书里的东西基本都是通用的。
- 很大一部分在C++Primer中都已经提到过了，只是这里单独提出来讲了。

## 第一章：习惯C++

### 条款1：视C++为一个语言的联邦

C++的多个编程范式：
- 继承自C的过程式编程
- C with classes的面向对象编程
- 基于模板的泛型编程，深奥的模板元编程
- STL，标准模板库

当从一个范式切换到另一个时，编程策略可能需要改变。每个子语言会有自己的规约和属于自己的最佳实践，用的哪一个部分，就使用什么原则。必须对这一点有强烈意识。

### 条款2：以const,enum,inline替换#define

- 以全局的常量定义替换宏定义的常量，以提供类型检查等一系列好处。
- 用enum值替换宏定义得到编译期常量，以避免非必要内存消耗，在模板中广泛使用(aka enum hack)。
- 用（模板）内联inline函数替换带参宏，获得更加健壮的程序。

宏定义和条件编译依然会扮演重要角色，但不再所有事情都要交给他们来做。

### 条款3：尽可能使用const

const可以修饰基本任何变量：
- 在所有可能的地方使用const，常量，返回值（避免对右值的修改），参数（避免对参数的修改），成员函数（支持const对象调用）。
- 充分理解指针引用的顶层底层const。
- 将所有不会修改对象的成员函数定义为const，以提供const对象或者const引用参数来访问。
- 在const对象中有想要修改的内容可以使用mutable。
- const和non-const重载成员函数逻辑相似，可以用non-const调用const辅以`const_cast`来避免重复（注意绝不应该反过来做）。

### 条款4：确定对象使用前已被初始化

不同部分的C++：
- 源自于C部分可能会沿用C的行为，对未初始化的内置类型变量不做任何事情，保持其为内存中的随机值。如局部变量，数组，类的内建成员等。
- 使用C++部分则会对内置类型做值初始化，如容器中的元素。
- 自定义类型的默认初始化由默认构造函数完成。

原则：
- 在任何时候保证对内置类型做初始化能避免很多错误，C++并不保证初始化他们。
- 使用构造函数成员初始化列表而非在构造函数体中对成员进行赋值以提高效率。
- 类中数据成员有着确定的初始化顺序，基类、成员按照声明顺序依次初始化，避免构造成员的初始化有数据依赖。
- 注意不同编译单元中的非局部静态对象的初始化顺序没有任何保证，避免这些对象的初始化之间存在依赖关系。
    - 最佳实践：使用单例模式返回局部静态变量的引用以替代全局的静态对象。规避初始化次序问题同时还能即用即初始化。

## 第二章：构造/析构/赋值运算

### 条款5：了解C++默认生成了哪些函数

- C++在一些情况下会默认生成默认构造函数、析构函数、拷贝构造函数、拷贝赋值运算符。
- 在已经有构造函数声明的情况下，不会生成默认构造。
- 在生成的函数的默认行为不合理、无法做到时则会将其生成为删除的函数。
    - 比如类中含有const成员、引用成员时拷贝赋值运算符会生成为删除。
    - 某个成员或者基类析构函数不可用时析构函数会生成为删除。
    - 某个成员或者基类没有默认构造时、有const或者引用成员时默认构造生成为删除。

### 条款6：若不想使用编译器自动生成的函数，就应该明确拒绝

不想要编译器默认生成的行为时，应该使用`=delete`明确声明为删除，或者自己定义。
- 在不支持`=delete`特性时比较老式的表达删除一个函数的意思的伎俩是：
    - 将不想要生成的函数声明为`private`，并且不做实现。
    - 或者继承一个拷贝构造、拷贝赋值被定义为private且未实现的基类`Uncopyable`。
- 当然现代C++中使用`=delete`就行了，不用这么绕弯子。

### 条款7：为多态基类声明虚析构函数

这已经是任何一个菜鸟都知道的共识了！

要点：
- 如果一个类要作为基类，那么可以肯定它需要一个虚析构函数。
- 如果一个类不会作为基类，那么不要将析构函数定义为虚函数。会增加一个虚指针的内存消耗。
- 如果你想要一个抽象类，但又找不到合适的函数来定义为虚函数。那么可以将析构函数定义为纯虚函数，但是同时也需要为其提供定义（合法可行且必须这样做，即使是抽象类甚至纯虚类，派生后这个子对象也是需要析构的）。
- 不要继承没有定义虚析构函数的类作为基类，使用多态特性时会出现内存泄漏。使用final阻止继承。

### 条款8：别让异常逃离析构函数

因为异常处理的过程中会调用析构函数销毁对象，如果在这期间再发生异常，那么将会导致UB。
- 所以永远不要在析构函数中抛出异常。
- 析构函数中的可能发生的异常都需要在函数体中就得到恰当的处理。
- 如果析构会发生无法恢复的异常，那么直接结束程序告知用户是一个好主意。
- 当然无法处理时另一个选择也可以选择吞掉异常，这取决于程序维持稳定运行重要还是暴露出所有的一个错误更重要。当然即使吞掉异常也应该将其记录在日志上之类的手段将其记录下来。
- 另一个策略是重新设计接口，将这些操作从析构函数中分离出来，将调用失败的处理交给使用类的客户去做。如果客户需要对这些异常做出反应，那么将其放在一个普通函数里面来做就是必须的。

### 条款9：永远不要在构造和析构函数中调用虚函数

因为在此时调用虚函数并不会达到我们想要的行为。
- 构造函数中，基类构造先于派生类构造，在构造基类时，this指代的对象是基类对象，虚函数当然也不会被解析为派生类的虚函数，因为这时候派生类成员都还没有被初始化。
- 析构函数中，派生类析构先于基类析构，在基类析构时，this同样指代基类对象，虚函数当然也会被解析为基类虚函数，此时派生类的成员已经被销毁了。
- 因为在执行基类的构造和析构时，派生类中的成员都是不可以用的，要么还没有初始化，要么已经销毁，所以这时不能将虚函数下降至派生类。
- 即是在构造函数和析构函数中，虚函数是不具备多态的，此时this也是指向该基类对象，而非派生类对象。此时做RTTI，`typeid(*this)`得到的将会是基类的`type_info`对象，`dynamic_cast`为派生类对象将会失败（而且这时派生类都不是完整类型，这样做必然是编不过的）。
- 除了不直接在构造和析构中调用虚函数，也应当注意不要间接调用虚函数。【当然除非这就是你期望的行为】。

### 条款10：令operator=返回一个*this的引用

这也是常识了，为了和内置运算符的语义对标，为自定义类型重载赋值，前置++/--，取成员，解引用这种返回左值的运算符都应该返回一个左值引用。以实现和内置类型类似的语义。

当然这并不是强制的，只是这是最佳实践，为了减少心智负担而已。

### 条款11：在operator=中处理自我赋值

我们应该假定使用代码的人可能会做出任何事情，包括自己给自己赋值，虽然这并没有什么意义。
- 某些时候赋值运算符中的逻辑本身就可以正确处理自赋值的情况，但某些情况并不能，每次写赋值运算符都应该考虑这种情况。
- 比如类中申请了内存，不要急于在还未复制右侧对象内存之前，就将自己的内存释放掉。
- 如果不好通过调整赋值中的操作顺序来处理自我赋值，那么也可以显式做一个判断。
- 通常的做法时，复制了右侧对象的内容分配好了新内存之后，再来释放左侧对象内存，兼具自我赋值安全和异常安全。
- 使用**copy and swap**技术来处理自我赋值也是一种常见手段：
    - 可以使用const引用传参，在拷贝复制内部做拷贝之后和左侧对象做swap。
    - 也可以使用另一种更加巧妙的手段：使用值传递（在此时复制），内部做交换之后返回`*this`。这种方式还会将移动赋值和拷贝赋值统一到一个赋值运算符中。
    - 适用于在实现了对象交换的类型（特化了`std::swap`）中这样做。

这也算是基本常识了。

### 条款12：赋值对象勿要忘记其每一个成分

- 拷贝构造和拷贝赋值运算符中一定不要忘记复制每一个成员。（所以，为类添加新成员时千万不要忘记在构造函数中添加初始化，在拷贝控制成员中添加其复制逻辑，如果有必要析构函数中也需要处理）。
- 除了自己的成员之外，如果是对一个派生类实现拷贝构造和拷贝赋值，那么一定不要忘记去对自己的基类部分执行拷贝。
    - 特别地，应该在拷贝赋值运算符中调用`Base::operator=(rhs)`。
- 通常来说，拷贝构造和拷贝赋值运算符不应该互相调用，因为前者是构造一个新对象，后者是对一个已有对象赋值覆盖其原有状态。如果两者有很多重复逻辑，应该定义一个新的私有成员函数给两者使用（通常命名为`init`）。

## 第三章：资源管理

### 条款13：以对象管理资源

- 将资源放进对象，依靠析构的自动调用来释放对象，无论是抛出异常还是中途控制流退出都能够释放资源。
- 可以使用智能指针来管理资源。
    - 获取资源后立即放到管理对象（智能指针）中。即是**RAII（Resource Acquisition Is Initialization，资源获取即初始化）**。 
    - 管理对象的析构函数确保资源被释放。

注意：这个条目中提到的`auto_ptr`现在已经有`shared_ptr unique_ptr weak_ptr`替代了，并且智能指针都支持自定义deleter了，所以现在也可以管理`new []`分配的内存了。


### 条款14：资源管理类中小心复制行为

当我们用RAII将资源释放委托给资源管理对象的析构函数后。需要小心资源管理对象的复制行为：
- RAII：资源在构造期间获得，析构时释放。
- 几种资源管理对象复制行为的处理：
    - 如果复制行为不合理，那么需要禁止复制（但一般允许移动），也就是使用类似于`unique_ptr`的行为。
    - 如果复制行为是合理的，效果是多个管理对象指向同一资源，那么可以使用引用计数管理。也就是`shared_ptr`的行为，可以通过自定义deleter来实现非内存类资源的释放。
    - 复制底层资源，这也是一种复制时可以考虑的行为。对资源做深拷贝，和原先的资源便没有了关系，独立了起来。
    - 转移底部资源拥有权，也可以配合`unique_ptr`使用。某些时候可能需要确保只有一个RAII对象指向底层资源，那么可以这样做。
- 不同的资源可能需要考虑不同的复制行为，但都可以用RAII来管理。如果单纯的智能指针功能不够，可能需要自定义RAII类来管理资源。

### 条款15：在资源管理类中提供对原始资源的访问

资源管理类将原始资源封装了一层，那么在需要这些原始资源的地方就需要提供对原始资源的访问：
- 智能指针的`get`接口提供原始指针，`. ->`运算符提供了对资源对象的成员访问。
- 在自定义资源管理类中可以提供智能指针`get`这样的显式转换接口，或者编写类型转换运算符以提供隐式转换。显式转换更安全，隐式转换更方便，各有优劣，怎样提供视具体情况选择。
- RAII类并不是为了封装，而是为了确保资源能够在析构时得到释放。
- 良好设计的类会隐藏客户不需要的部分，提供用户需要的所有东西。

### 条款16：成对使用new和delete时采取相同形式

`new/delete`以及`new[]/delete[]`是配套的，不能混用，这也是常识了。
- 特别是用智能指针管理`new[]`分配的内存时需要自定义删除器为`[](T* p) -> void{ delete[] p; }`。
- 用RAII管理时，在构造和析构中一定要配套使用。并且多个构造中必须要使用相同的`new`运算符。

### 条款17：以独立语句将new得到的指针置入智能指针

简单来说就是，防止资源创建和资源被转换为资源管理对象之间发生干扰（比如抛出异常），导致内存泄漏。
- 典型如使用智能指针传参数时，先将智能指针构造出来再传入接受智能指针的函数。而不是在函数调用中直接构造临时的智能指针。
- 【因为编译器对于跨越语句的操作没有重新排列的自由度】。

## 第四章：设计与声明

### 条款18：让接口容易被正确使用，不易被误用

应该在所有接口中努力达成“容易被正确使用，不易被误用”的原则：
- 促进正确使用的方法有：设计更符合直觉的接口，设计与内置类型行为兼容的接口。
- 防止误用的方法有：建立新类型（通过类型系统防止错误数据），限制类型上的操作，束缚对象的值，消除客户的资源管理责任（典型如使用智能指针）。
- `std::shared_ptr`自定义删除器，可以防止DLL问题（跨DLL释放内存，一般会报运行时错误），自动解除互斥锁等。
- 总之：在最理想的情况下，如果用户错误地使用了接口，那么应该出现编译错误，这基本不可能达不到，但应该为此而努力。

### 条款19：像设计类型一样设计类

也就是说设计类从来不只是定义一个class那么简单，要像语言设计者设计内置类型那样谨慎。一些设计要点：
- 类的对象如何被创建，影响到构造析构函数即内存分配和释放函数（`operator new/delete/new[]/delete[]`）。
- 对象的初始化和赋值该有什么样的区别。
- 对象被值传递时，拷贝构造函数怎么实现。
- 对象的合法状态，也就是那些值对对象来说是有效的，这将决定了成员函数中的错误检查、抛出异常等。
- 配合继承体系。如果新类是否继承自既有的类，那么需要遵守既有的基类的影响。如果你的类开放给用户作为基类，那么将影响函数的声明，尤其是析构函数需要声明为虚函数。
- 新的类型需要怎么样类型转换，其他类型转换到该类型，该类型转为其他类型。
- 是否需要为新类型重载运算符，那些运算符是合理的。
- 不该对外部暴露的函数应该声明为private。
- 谁会来使用这个新的类，也就是这个类的用户是谁。这将决定对外暴露的接口，对派生类暴露的接口，非成员函数接口。
- 这个类是一个独立的类，还是一整族类，如果是一族类，那么也许应该定义为类模板。
- 你确实需要一个新的类吗？如果只是在现有类基础上派生，并加上很少的功能，那么为什么不直接修改现有类，或者添加几个函数解决。

一个好的设计需要对上述所以问题作出自己的回答，确保在所有方面做到最好。

### 条款20：以const引用参数替代值传递

- 永远记住值传递会对类型调用拷贝构造函数进行拷贝。
- 对自定义类型来说，在非必要以值传递的方式传递时，都应该以引用参数传递，不会修改源对象则使用const，会则不使用const。
- 在多态场景中，采用引用传递也可以避免对象被切割为基类对象。
- 对于内置类型则一般采用值传递。
- 一些特殊的自定义类型比如智能指针、STL中的迭代器和函数对象，一般来说采用值传递更为合适。

### 条款21：必须返回对象时，不要试图返回引用

简单来说就是不要试图在不应该返回引用的地方返回一个引用。
- 比如返回表示计算结果的右值的重载运算符（`operator +-*/%`等）。
- 不要试图返回局部变量的引用。
- 不要去焦虑这一点拷贝构造导致的性能损失，现代C++中有移动语义以及复制消除（构造函数消除、RVO、NRVO等）的优化手段。

### 条款21：将成员变量声明为private

封装就是要将成员声明变量为private，只对外部暴露出接口：
- 成员变量隐藏的背后，可以为所有可能的实现提供弹性。可以在用户无感知的情况下修改背后的实现。
- 隐藏成员才能确保类的约束条件通过接口函数得到恰当地维护，访问权限得到更精细的控制，而非任由用户直接读取修改成员变量。
- 封装同样保留了日后变更的权利，不封装几乎意味着不可改变。没有人会需要一个不可改变的程序。
- 封装性（隐藏的程度）与其被修改时可能造成的代码破坏量成反比：
    - public成员的修改可能破坏大量用户代码。
    - protectd成员修改可能破坏大量继承了该类的代码。
    - 唯有private成员具有最高的封装性，得以在用户无感知的情况下替换修改。（友元破坏了封装，所以友元除外）。
    - 所以从封装角度看，只有两种访问权限：private和其他。
- 最后：记住将所有实现而非接口相关的内容封装起来，声明为private。这可以给与用户访问数据的一致性、可细微划分的访问控制、约束条件得到保证，并提供给类的作者充分的实现弹性。

### 条款23：宁以非成员、非友元替换成员函数

如果一个非成员函数与友元函数或者成员函数提供同样的功能，那么应该选择非成员非友元函数。
- 因为成员函数和友元函数会增加能够访问类中私有成分的函数数量。（能够访问类中私有成分越多，封装性越弱）。
- 所以实现为一个非成员非友元函数会具有更强的封装性。
- 一个好的选择是将其放在与类同一个命名空间中作为一个非成员非友元的全局函数。
- 这也能降低编译依赖性，也就是代码耦合度更低。

### 条款24：若所有函数皆需类型转换，请为此采用非成员函数

很容易理解，如果定义为成员函数，那么第一个隐式参数this是不能够由其他类型参数隐式转换而来的，必须显式构造之后才能使用其调用成员函数。
- 最常见的是重载的运算符，比如算术运算`+-*/%`这种。定义为非成员函数以允许所有参数都能够隐式转换会更加合理一些。
- 这通常用在可以由其他类型隐式转换为该类型时。

### 条款25：考虑写出一个不抛出异常的swap函数

`std::swap`函数模板的平凡实现就是我们想的那样，利用一个临时变量，交换两个变量的值。
- 当要实现交换函数时，通常我们是使用我们的自定义了类型对`std::swap`做一个（全）特化（特化到命名空间`std`中）。
- 一般来说的实践是定义一个`swap`成员函数来做交换，然后`std::swap`特化直接调用即可。
- 但如果我们定义的是类模板而非普通类时，就不能够对`std::swap`做偏特化了（因为C++只支持对类做偏特化，不支持对函数做偏特化），这时的做法时给`std::swap`添加一个新的重载版本（然而直接加在`std`是不合法的）。
- 但是有一点比较特殊的是命名空间`std`，我们可以对其中的模板做特化，但是不能往其中添加新的模板。所以通常的做法是，将类和非成员的`swap`模板放到同一个命名空间。因为对类做函数调用时同时会去类所在的命名空间查找名字，所以这样做就足够了。调用时应该使用`swap`而不是`std::swap`。【如果没有使用命名空间，那么就是定义全局命名空间，这也是可行的，怎么用取决于你】。
- 对于类模板来说，在新的或者全局命名空间定义一个新的`swap`模板是最佳选择。
- 而对于普通类来说，也可以定义一个普通函数重载版本的`swap`。通常情况下的建议是特化`std::swap`和普通函数定义同时做，他们都调用类内部的`swap`。
- 无论什么情况，使用时的最佳实践是：
    - 在作用域内`using std::swap;`，就像这样：
    ```C++
    template<typename T>
    void doSomething(T& a, T& b)
    {
        using std::swap;
        ...
        swap(a, b);
        ...
    }
    ```
    - 这样做时，匹配顺序会是：T类型同命名空间中的`swap`、自己添加的特化版本的`std::swap`、非特化版本的`std::swap`库实现。
    - 而不应该直接使用`std::swap`（这样会忽略同命名空间中的`swap`实现，如果是类模板，就意味着直接去实例化`std::swap`）。
- 值得注意的是：`swap`的使用就是为了让成员在拷贝和移动时确保异常安全，所以应该确保**成员版本的swap**（最终被调用的那个实现）不抛出任何异常。

另外：
- 更一般地，重载决议时，会将所有参数所在命名空间中的同名函数加入可行函数集（在没有说明所调用函数的命名空间的情况下）。

## 第五章：实现

本章关注实现中的各种细节问题：
- 变量定义时机。
- 不要滥用转型。
- 避免返回内部handle。
- 为异常安全而努力，避免异常导致的资源泄漏。
- 不要滥用内联。
- 降低代码的耦合度。

### 条款26：尽可能延后变量定义的出现时间

- 通常来说，最好就是变量即用即定义，也就是直到要用到变量的前一刻再定义。
- 并且定义的时候用一个有意义能用到的值来初始化，好过默认构造之后再赋值。
- 在循环中使用一个多轮循环中没有关联的临时变量时，在循环前定义还是每一轮循环定义则取决于一组构造+析构与一个赋值操作谁的成本更高。
    - 通常来说两者成本是差不多的，非效率敏感部分代码是可以在循环中定义的，会更加清晰，且不会延长该临时变量的生命周期。

### 条款27：尽量少做转型

显式类型转换同时破坏了类型系统，非必要不应该使用，优秀的代码很少使用显式类型转换：
- C中转型格式：
    - `(T)expression` 继承自的C的最原始的转型风格。
    - `T(expression)` 构造转型风格。
    - 两者等价，前者在C++中不应该使用，后者常用在要构造一个临时变量的地方，这种情况亦可理解为临时的纯右值对象的构造，通常是合理的。
    - C风格转换会尝试去使用C++的`static_cast const_cast`，如果不合理则会使用`reinterpret_cast`。
- C++中显式类型转换：
    - `const_cast<T>(expression)`
    - `dynamic_cast<T>(exression)`
    - `reinterpret_cast<T>(exression)`
    - `static_cast<T>(exression)`
- 通常来说不应该用C风格转换，当然如果语义是调用转换构造构造一个临时对象，那是可以使用的。
- 通常也不应该使用C++显式类型转换，可能存在些许例外：
    - `const_cast`应该只用于类似于条款3所述的等少量场景。
    - `dynamic_cast`具有不小的运行时消耗。试着使用无需`dynamic_cast`的设计：
        - 不使用基类指针，而使用派生类指针保存派生类对象。
        - 添加虚函数，在基类添加空实现，从而使用多态来处理，避免转换。
    - `reinterpret_cast`通常意味着坏的设计，通常不会需要重新解释内存，除非一些非常非常特殊的场景，尝试使用其他方法替代。
    - `static_cast`也应该尽量被避免，非要用也应该封装在函数中，而不是让用户来做。典型如`std::move`。
- 就算要使用显式类型转换，也应该使用C++风格而不是C风格。（当然单参数构造一个临时对象的风格依然很常用，因为可以理解为一个临时对象的构造，这是使用`static_cast`还会更费解）。

### 条款28：避免返回指向对象内部成分的句柄（handle）

这里的句柄包括指针、引用、迭代器或者传统的句柄。
- 典型如`std::shared_ptr::get`返回的原始指针，通常我们只应该将其用于只能接受原始指针而不能接受智能指针的函数调用场景，调用结束后即释放，避免出现空悬的句柄。
- 其他类型同理，返回对象内部句柄代表着封装性的降低，内部封装的成员的访问级别其实被提高了。
- 对一个const对象返回其内部句柄，并且可通过句柄修改内部状态的话，在逻辑上就是错误的（语法却是合法的）。
    - 要让const成员函数的行为像一个const，此时应该在返回的句柄上加上const修改时，让其变为只读。
- 不得不用的时候避免返回的句柄空悬也是非常重要的。使用得到的句柄时避免源对象已经被析构：
    - 如果将返回的句柄作为返回值，可能应该值返回，而不是返回指针、引用或者迭代器。
    - 能用外层对象完成的事情就避免使用内部句柄来做。
- 比较特殊的情况下可能不得不这么做，比如`operator[]`、迭代器等。但都要时刻注意使用时决不能在对象析构之后还在用返回的句柄。

### 条款29：为异常安全而努力是值得的

编写异常安全的代码，给与了程序更高的健壮性，也给了用户在异常抛出时更好的操作空间：
- 当异常抛出时，有异常安全性的函数需要满足：
    - 不泄露任何资源。
    - 不允许数据损坏。
- 防止资源泄漏可以使用资源管理类利用RAII特性解决，将发生异常时的资源释放动作委托给RAII类的析构。见第三章。
- 不允许数据损坏就要求我们小心安排申请新资源和释放旧资源的顺序：
    - 通常做法是统一先申请新资源/获取并计算新状态，成功之后再释放旧资源/设置新状态。避免旧的资源已经释放，但新的资源却申请失败的情况。
    - 特别是有多个资源和状态时，要避免一部分状态已更新，一部分还没有更新时抛出异常的问题。
- 异常安全提供以下三个程度的保证：
    - **基本承诺**：异常抛出时，程序内内部事物依然处于有效状态，但状态是否改变并不确定。
    - **强烈保证**：异常抛出时，程序状态不发生任何改变，和调用前一致。
    - **不抛出(nothrow)保证**：承诺绝不抛出异常，通常我们会为这种函数加上`noexcept/throw()`修饰。
- 如果函数不提供以上三种保证之一，那么它就不具备异常安全性。
- 编写异常安全的代码时，我们需要抉择提供哪一种保证：
    - 不抛出保证很诱人，那么很简单的函数很容易提供不抛出保证，但是如果我们调用了任何可能抛出异常的函数，那就不可能实现了。
    - 通常情况下都是在基本承诺和不抛出保证中做选择。
    - 实现强烈保证的一个一般化的设计策略就是我们前面提到过的copy and swap技术。先创建打算修改的对象的副本（用智能指针保存以避免资源泄漏），在副本上做状态修改，修改完之后在与目标对象做交换（swap操作通常都需要承诺不抛出异常）。典型实现示例：
    ```C++
    // member of Foo example:
    // Mutex mutex; 
    // shared_ptr<FooImpl> pImpl;
    void Foo::someExceptionSafeFunc(const Bar& bar)
    {
        using std::swap;
        Lock m(&mutex); // RAII manage mutex
        // copy old states
        // RAII make sure the copy will surely be released
        shared_ptr<FooImpl> pNew(new FooImpl(*pImpl));
        // set new states
        pNew->xxxMember.reset(new Bar(bar));
        ++pNew->xxxMember;
        // swap
        swap(pImpl, pNew);
    }
    ```
    - copy and swap技术提供了一个“全有或者全无”的一个好方法。
    - 但是因为一个函数能提供的异常安全保证取决于函数实现中调用的所有函数中最弱的那个保证，如果函数使用了copy and swap提供强烈保证，但是额外调用了一些只提供基本保证的函数，那么就只能有基本保证。要提供强烈保证就必须在基本保证的函数调用两侧去记录原始状态，在发生异常时做状态恢复，会有一定的性能代价。
    - 上面所说都是函数只操作局部状态的情况，如果函数还会操作全局状态，那么提供强烈保证就更为困难了。
- 总结：
    - 强烈保证不一定容易实现，很多时候强烈保证是不切实际的（可能的巨量效率损失与繁杂的实现成本），这时尽可能提供基本保证也许是更好的选择。
    - 因为异常安全是传递的，所以一个程序要么是全局异常安全的，要么是不安全的。不存在说局部异常安全的。
    - 但并不应该滑坡谬误，已经存在异常不安全的代码不是继续编写异常不安全的代码和不再为异常安全做任何努力的理由。任何时候都应该努力编写出异常安全的代码。
    - 异常安全应该作为接口的一部分，被写进文档中。

作为曾今很少为异常安全考虑的人来说，这一节具有非凡的指导意义。

### 条款30：透彻了解inline的里里外外

函数内联是典型的空间换时间策略，减少函数调用的开销，但会增大程序的体积。取决于你对哪一个资源的敏感度更高。
- 函数体足够小是使用内联的一个有效理由，当函数体小到比函数调用的开销更小时，内联就只有好处没有坏处了（减小程序体积同时提高效率）。
- 内联只是一个向编译器提供的建议，不是强制命令。
- inline的细节：
    - 在类中定义函数是隐式内联的。
    - C++的内联是在编译时做的。
    - 显式的内联建议通常将函数定义在头文件中，为了能够将代码嵌入到调用的位置，编译器需要知道函数体是什么。因为最终不会生成函数，所以可以有多份同样的定义而不会造成符号重定义。
    - 模板通常也会将定义写在头文件中，但满足同样规则，并不会直接隐式内联，要内联同样需要显式使用inline。并且记住他们定义在头文件里面并不是他们应该内联的理由。
    - 编译器并不会执行过于复杂的内联。
    - 虚函数的调用也不会执行内联（除非非常简单的编译期就能确定调用哪一个的，属于编译优化的一种）。
    - 多数编译器如果无法内联一个inline函数，可能会给出警告。
    - 某些时候编译器虽然内联了某个函数，但却依然生成了函数代码（比如需要取其地址时）。同理编译也通常不为通过函数指针调用的函数内联。
    - 构造和析构函数虽然函数体里面没什么东西，但是通常他们会做很多事情，基类和成员的构造、析构，异常处理等。通常也不是内联的好候选。
- 内联也可能有一系列其他缺点：
    - 因为没有生成函数代码导致定义发生改变时，必须重新编译。内联增加了模块间的耦合度。
    - 很多编译器在调试环境下禁止内联。

总结：
- 只对必要的代码做内联。
- 80-20经验法则：平均而言一个程序往往将80%的时间花在20%的代码上。在profiling的时候再来做优化可能才是一个好选择，毕竟过早优化是万恶之源。

### 条款31：将文件间的编译依存关系降至最低

首先分别考虑类和函数的声明和定义对其使用到的自定义数据类型的声明的定义依赖程度。
- 最根本原则就是，编译器需要能够有足够的的信息来生成代码。

对于函数来说：
- 函数声明中：参数、返回值类型中可以出现任何只声明了但未定义的类型，以及其引用或指针。
- 函数定义中：
    - 参数中、返回值类型中、函数体中可以出现只声明未定义类型的引用和指针。但不能通过引用和指针去引用类型的成员，某些情况下就算只使用了引用或者指针也需要完整类型，比如做了`static_cast dynamic_cast`这种类型转换时需要转换构造函数/类型转换运算符、类的派生关系可见，换言之也就需要定义可见。
    - 参数、返回值、函数体中使用了自定义类型的变量，或者通过任何方式引用了自定义类型的任何成员，都需要自定义类型的定义可见而不能只有声明（即是完整类型）。

对于类来说：
- 成员函数声明和定义对用到的类型与普通函数的要求一致。
- 数据成员是指针或者引用的话，只需要声明可见即可，如果是该自定义类型的数据成员的话，则要求是完整类型（以便确定占用内存空间）。

为了避免编译依赖我们应该做什么：
- 一般的构想是，能依赖于声明就不要依赖于定义。
- 鉴于在头文件中我们只放声明（内联函数、模板除外），所以只有在类成员中包含自定义类型的变量（而非指针引用）时，类定义就会依赖于成员类型的定义。
    - 此时只有这个成员类型的定义有修改就会影响所有使用了这个类以及其他用了这个成员类型的定义的函数、类的代码。降低编译效率。
    - 解决方法可以是将成员类型换为其指针或者引用，但会带来内存资源管理的复杂度。
    - 当然包含标准库类型一般不会成为编译瓶颈，标准库类型不会更改，并且一般都有预编译头。
- 考虑到上面一点，有两种手段可以实现使用该类的代码不依赖于其成员：
- 一种叫做Handle classes（句柄类）：
    - 典型实现如下：
    ```C++
    class FooImpl;
    class Foo
    {
    public:
        Foo(Args ... args) : pImpl(make_shared<FooImpl>(args...)) {}
    private:
        shared_ptr<FooImpl> pImpl;
    };
    ```
    - 将一个类型的实现全部委托给其实现类，接口类中仅仅只做一个转调。这种实现方式也叫做pImpl idiom（pImpl惯例）。
    - 所有涉及到这个类内部实现的东西都在其实现类中，修改成员、添加成员等不会影响接口的操作，不会引起使用该类的代码的重新编译。
- 另一中实现叫做Interface classes（接口类）：
    - 典型实现：
    ```C++
    class FooInterface
    {
    public:
        FooInterface(Args ... args) = 0;
        virtual ~FooInterface() = 0;
        virtual xxx otherVirtualMethods() = 0;
        xxx someNonVirtualFunc() { ... }
    
        // factory
        static shared_ptr<FooInterface> create(Args ... args)
        {
            return shared_ptr<FooInterface>(new Foo(args...));
        }
    };
    class Foo : public FooInterface
    {
    public:
        Foo(Args ... args) {}
        ~Foo() {}
        xxx otherVirtualMethods() {}
    };
    ```
    - 即将接口和实现分离，定义一个抽象类作为基类，接口全部定义为虚函数，在派生类中实现。非虚的接口则可以实现。
    - 将构造委托给静态工厂来做。
    - 实现内部的改变也不会影响到使用接口类的代码，只要接口不发生改变，用户代码都不需要重新编译。
- 但这两种方法都存在一定缺点：
    - 前者进行了一层转调。
    - 后者所有接口调用都是虚调用，有一层间接层次，并且增加了一个虚指针的内存消耗。
    - 都有一定性能损耗。
- 这两种方法也都可以隐藏内部实现细节，在实际生产中广泛使用，且更多用在对外部的API/SDK等地方。
- 实际使用时还是应该权衡编译速度、运行时代码、代码解耦需求程度、代码规模等因素综合考虑是否使用。
- 某些程序库还会提供单独的仅有声明的头文件以提供给自定义的头文件使用（如标准库`<iosfwd>`中声明了IO相关类型），而包含定义的头文件则提供给实现源文件来使用。
- 以上做法是否涉及模板都可以使用。